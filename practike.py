

## Простейшие арифметические операции (1)
## 
## Написать функцию arithmetic,
##  принимающую 3 аргумента: первые 2 - числа,
##  третий - операция, которая должна быть произведена над ними.
##  Если третий аргумент +, сложить их; если —, то вычесть; * — умножить;
##  / — разделить (первое на второе). В остальных случаях вернуть строку 
## "Неизвестная операция".






# def arithmetic(a, b, operation):
#     """
#     Функция, выполняющая арифметические операции над двумя числами.
# 
#     Args:
#         a (int): Первое число.
#         b (int): Второе число.
#         operation (str): Операция, которую нужно выполнить. Может быть "+", "-", "*", "/".
# 
# 
#     Returns:
#         int или float: Результат операции. Если операция неизвестна, возвращает строку "Неизвестная операция".
#     """
#     if operation == "+":
#         return a + b
#     elif operation == "-":
#         return a - b
#     elif operation == "*":
#         return a * b
#     elif operation == "/":
#         if b != 0:
#             return a / b
#         else:
#             return "Деление на ноль!"
#     else:
#         return "Неизвестная операция"
# 
# 
## Пример использования функции
# a = int(input("Введите первое число: "))
# b = int(input("Введите второе число: "))
# operation = input("Введите операцию (+, -, *, /): ")
# 
# result = arithmetic(a, b, operation)
# print("Результат:", result)
# 
# def main():
#     while True:
#         print("Меню:")
#         print("1. Прибавить два числа")
#         print("2. Убавить два числа ")
#         print("3. Умножить два числа")
#         print("4. Разделить два числа")
#         print("5. Выход")
# 
#         choice = int(input("Выберите пункт меню: "))
# 
#         if choice == 1:
#             a = int(input("Введите первое число: "))
#             b = int(input("Введите второе число: "))
#             print("Результат:", arithmetic(a, b, "+"))
#         elif choice == 2:
#             a = int(input("Введите первое число: "))
#             b = int(input("Введите второе число: "))
#             print("Результат:", arithmetic(a, b, "-"))
#         elif choice == 3:
#             a = int(input("Введите первое число: "))
#             b = int(input("Введите второе число: "))
#             print("Результат:", arithmetic(a, b, "*"))
#         elif choice == 4:
#             a = int(input("Введите первое число: "))
#             b = int(input("Введите второе число: "))
#             print("Результат:", arithmetic(a, b, "/"))
#         elif choice == 5:
#             break
#         else:
#             print("Неверный выбор!")
# 
# if name == "main":
#     main()
#     





## Високосный год (2)
## Написать функцию is_year_leap, принимающую 1 аргумент — год,
##  и возвращающую True, если год високосный, и False иначе.





#     
#  def is_year_leap(year):
#     if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
#         return True
#     else:
#         return False
#         year = int(input("Введите год: "))
#          result = is_year_leap(year)
# print(result)
#    
# 
# 
# 
# 
#  
### Квадрат (3)

## Написать функцию square,
##  принимающую 1 аргумент — сторону квадрата,
##  и возвращающую 3 значения (с помощью кортежа):
##  периметр квадрата, площадь квадрата и диагональ квадрата.




# import math
# 
# def square(side):
#     """
#     Возвращает периметр, площадь и диагональ квадрата.
# 
#     Args:
#         side (int): Сторона квадрата.
# 
#     Returns:
#         tuple: (периметр, площадь, диагональ)
#     """
#     perimeter = 4 * side
#     area = side ** 2
#     diagonal = side * math.sqrt(2)
#     return perimeter, area, diagonal
# 





## Времена года (4)

## Написать функцию season, 
## принимающую 1 аргумент — номер месяца (от 1 до 12), 
## и возвращающую время года, которому этот месяц принадлежит 
## (зима, весна, лето или осень). 



# def season(a):
#   
#     if a in [1, 2, 3]:
#         return "Зима"
#     elif a in [4, 5, 6]:
#         return "Весна"
#     elif a in [7, 8, 9]:
#         return "Лето"
#     elif a in [10, 11, 12]:
#         return "Осень"
#     else:
#         return "Неправильный номер месяца"





## Банковский вклад (5)
## Пользователь делает вклад в размере a рублей сроком на years лет под 10% годовых (каждый год размер его вклада увеличивается на 10%.
## Эти деньги прибавляются к сумме вклада, и на них в следующем году тоже будут проценты).
## Написать функцию bank, принимающая аргументы a и years, и возвращающую сумму,
##  которая будет на счету пользователя.







# def bank(a, years):
#     """
#     Рассчитывает сумму на счету пользователя после years лет
#     при годовой ставке 10%.
# 
#     Args:
#         a (float): Начальная сумма вклада
#         years (int): Срок вклада в годах
# 
#     Returns:
#         float: Сумма на счету пользователя после years лет
#     """
#     for _ in range(years):
#         a *= 1.1  # Увеличение суммы на 10% каждый год
#     return a
# 
# Пример использования
# a = float(input("Введите начальную сумму вклада: "))
# years = int(input("Введите срок вклада в годах: "))
# print("Сумма на счету пользователя после {} лет: {:.2f}".format(years, bank(a, years)))






## Простые числа (6)
## Написать функцию is_prime, принимающую 1 аргумент — число от 0 до 1000,
##  и возвращающую True, если оно простое, и False - иначе.






# def is_prime(a):
#     """
#     Проверяет, является ли число простым.
# 
#     Args:
#         a (int): Число от 0 до 1000.
# 
#     Returns:
#         bool: True, если число простое, False иначе.
#     """
#     if a < 2:  # Числа меньше 2 не являются простыми
#         return False
#     for i in range(2, int(a ** 0.5) + 1):  # Проверяем делители до квадратного корня
#         if a % i == 0:  # Если число делится на i, оно не простое
#             return False
#     return True  # Если число не делится ни на одно из чисел, оно простое









##  (7)

# Качели
# Ограничение по времени: 0.5 секунды
# Ограничение по памяти: 256 мегабайт
# Трое друзей — Аня, Боря и Саша — пришли на детскую площадку, чтобы покачаться
# на качелях-балансире. Качели представляют собой длинную балку, закреплённую в центре, на которую дети садятся с разных концов.
# Массы детей равны А, В и С кг. Чтобы держать баланс на качелях, разница масс на двух концах качелей должна быть не более D кг. Друзьям повезло: рядом с площадкой оказалась груда достаточно тяжёлых камней. Один из детей может взять с собой любой камень, чтобы сделать разность масс на концах качелей допустимой. Помогите друзьям определить минимальную массу камня, благодаря которому они смогут покачаться на качелях.
# Формат входных данных
# Программа получает на вход три числа А, В, С, записанных в отдельных строках, друзей. В четвёртой строке записано число D — наибольшая допустимая разница масс на концах качелей. Все числа целые, положительные и не превосходящие 10o.
# массы
# Формат выходных данных

# Формат выходных данных
# Программа должна вывести одно целое число минимально необходимую массу камня, которую нужно добавить на одну из сторон качелей, чтобы друзья смогли покачаться
# на них, сев оптимально. Если камень им не понадобится, программа должна вывести число 0.
# Система оценки
# Решения, правильно работающие, когда все входные числа не превосходят 105, будут оцениваться в 40 баллов.
# Замечание
# В первом примере Аня и Саша сядут на одну сторону, их суммарная масса будет равна 65 кг. На другую сторону сядет Боря, взяв 15-килограммовый камень, тогда масса Бори с камнем составит 55 кг.
# Разница весов на концах качелей примет значение 10 кг. Во втором примере Аня и Боря сядут на одну сторону (50 кг), Саша на другую сторону (45 кг). Разница весов будет равна 5 кг, поэтому камень не понадобится.

# Ввод      # Вывод
# 30          15
# 40
# 35
# 10

# Ввод 
# 30            # Вывод
# 20               0
# 45
# 10

# def min_stone_weight(a, b, c, d):
#     weights = [a, b, c]
#     weights.sort()  # Сортируем веса по возрастанию
    
#     # Проверяем две возможные комбинации:
#     # 1. Самый тяжелый на одной стороне, двое легких на другой
#     # 2. Двое тяжелых на одной стороне, самый легкий на другой
#     diff1 = abs(weights[2] - (weights[0] + weights[1]))
#     diff2 = abs((weights[1] + weights[2]) - weights[0])
    
#     if diff1 <= d or diff2 <= d:
#         return 0  # Камень не нужен
#     else:
#         return min(diff1 - d, diff2 - d)

# # Считываем входные данные
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())

# # Вычисляем и выводим результат
# result = min_stone_weight(a, b, c, d)
# print(result)

# Определяет функцию min_stone_weight, которая принимает массы трех детей (a, b, c) и максимально допустимую разницу масс (d).
# Сортирует массы по возрастанию для упрощения расчетов.
# Рассматривает два возможных распределения детей:
# Самый тяжелый ребенок на одной стороне, двое легких на другой.
# Двое самых тяжелых на одной стороне, самый легкий на другой.
# Вычисляет разницу масс для обоих случаев.
# Если хотя бы в одном случае разница не превышает допустимую, возвращает 0 (камень не нужен).
# Иначе возвращает минимальную массу камня, необходимую для баланса.
# Считывает входные данные и выводит результат.



# Фонари
# Ограничение по времени: 1 секунда
# Ограничение по памяти: 256 мегабайт
# Вдоль прямой улицы на равном расстоянии располагаются N домов. Будем считать
# расстояние между домами за единицу длины.
# Около каждого дома можно поставить один фонарь. Всего имеется А фонарей, которые могут освещать дома на расстоянии X (включительно), и В фонарей, которые могут освещать дома на расстоянии Y (включительно). В частности, при Х = 0 или Y = 0 такой фонарь освещает только тот дом, у которого он установлен.
# Вам необходимо расставить минимальное число фонарей так, чтобы все дома были освещены. Один дом может быть освещён несколькими фонарями. Освещать участки улицы между домами необязательно.
# Формат входных данных
# Первая строка входных данных содержит целое число N (1 ≤ N ≤ 105). Следующие
# четыре строки содержат целые неотрицательные числа А, Х, В и У соответственно, которые не превосходят 105.
# Формат выходных данных


# Программа должна вывести столько строк, сколько фонарей необходимо установить. Каждая строка должна содержать два целых числа через пробел - координату фонаря и расстояние, которое он освещает (то есть одно из чисел X или Y). Координаты представляют из себя целые числа от 1 до N, рядом с каждым домом можно поставить только один фонарь.
# При наличии нескольких правильных ответов можно вывести любой из них. Если ответа не существует, программа должна вывести одно число -1.
# Система оценки
# Решения, правильно работающие при A = 0 или В = 0, будут оцениваться в 30 баллов. Решения, правильно работающие при A ≠ 0, B ≠ 0, n < 1000, будут оцениваться
# в 40 баллов.
# Замечание
# В ответе к первому примеру фонарь у дома 2 освещает также дома 1 и 3, фонарь
# у дома 5 — также дома 3, 4, 6 и 7, а фонарь у дома 9 — также дома 8 и 10. В результате все дома освещены. Во втором примере фонарей недостаточно.
# Ввод      вывод      
# 10           2 1
# 3            5 2
# 1            9 1
# 1
# 2


# Ввод      вывод      
# 10           -1
# 1
# 1
# 1
# 2






# def place_lanterns(n, a, x, b, y):
#     lanterns = []
#     current_house = 1

#     # Всегда используем фонарь с большим радиусом первым
#     if x > y:
#         a, b = b, a
#         x, y = y, x

#     while current_house <= n:
#         if b > 0:
#             lanterns.append((current_house, y))
#             current_house += 2*y + 1
#             b -= 1
#         elif a > 0:
#             lanterns.append((current_house, x))
#             current_house += 2*x + 1
#             a -= 1
#         else:
#             return [-1]

#     # Проверяем, все ли дома освещены
#     if current_house > n:
#         return lanterns
#     else:
#         return [-1]

# # Считываем входные данные
# n = int(input())
# a = int(input())
# x = int(input())
# b = int(input())
# y = int(input())

# # Размещаем фонари
# result = place_lanterns(n, a, x, b, y)

# # Выводим результат
# if result == [-1]:
#     print(-1)
# else:
#     for lantern in result:
#         print(f"{lantern[0]} {lantern[1]}")
        
        

# def place_lanterns(n, a, x, b, y):
#     # Инициализация списка для хранения размещенных фонарей
#     lanterns = []
#     # Начинаем с первого дома
#     current_house = 1

#     # Продолжаем размещать фонари, пока не дойдем до последнего дома
#     while current_house <= n:
#         # Если есть фонари типа A и (нет фонарей типа B или фонари A освещают дальше)
#         if a > 0 and (b == 0 or x >= y):
#             # Размещаем фонарь типа A
#             lanterns.append((current_house, x))
#             # Переходим к следующему неосвещенному дому
#             current_house += 2*x + 1
#             # Уменьшаем количество доступных фонарей типа A
#             a -= 1
#         # Если есть фонари типа B
#         elif b > 0:
#             # Размещаем фонарь типа B
#             lanterns.append((current_house, y))
#             # Переходим к следующему неосвещенному дому
#             current_house += 2*y + 1
#             # Уменьшаем количество доступных фонарей типа B
#             b -= 1
#         # Если фонарей не осталось, а дома еще есть
#         else:
#             return [-1]  

#     # Проверяем, все ли дома освещены
#     if current_house > n + x or (b == 0 and current_house > n + y):
#         return lanterns  # Все дома освещены
#     else:
#         return [-1]  # Не все дома освещены

# # Считываем входные данные
# n = int(input())  # Количество домов
# a = int(input())  # Количество фонарей типа A
# x = int(input())  # Радиус освещения фонарей типа A
# b = int(input())  # Количество фонарей типа B
# y = int(input())  # Радиус освещения фонарей типа B

# # Размещаем фонари
# result = place_lanterns(n, a, x, b, y)

# # Выводим результат
# if result == [-1]:
#     print(-1)  # Невозможно осветить все дома
# else:
#     # Выводим координаты и типы размещенных фонарей
#     for lantern in result:
#         print(f"{lantern[0]} {lantern[1]}")


# Функция place_lanterns пытается разместить фонари, начиная с первого дома.

# На каждом шаге она выбирает, какой тип фонаря использовать (с радиусом освещения X или Y), отдавая предпочтение фонарю с большим радиусом.

# После размещения фонаря, мы перемещаемся к следующему неосвещенному дому.

# Если фонари закончились до того, как все дома освещены, функция возвращает [-1].

# Если все дома освещены, функция возвращает список размещенных фонарей.

# Основная часть программы считывает входные данные, вызывает функцию и выводит результат в требуемом формате.







# Красная Шапочка на болоте
# Ограничение по времени: 1 секунда
# Ограничение по памяти: 256 мегабайт
# Красная Шапочка отправилась на болото для сбора клюквы, чтобы испечь пирожки для бабушки. Клюквенное болото представляет собой координатную прямую. Берег, на котором стоит Шапочка, имеет координату 0, а клюквенная поляна координату N + 1. В точках с координатами 1, 2, ..., N расположены кочки.
# Первоначально у девочки E единиц энергии. Красная Шапочка может прыгнуть из точки Х в точку у (х < y), потратив на это (y - х) единиц энергии, то есть количество единиц затраченной энергии равно расстоянию между кочками. После того как девочка приземлится на кочке с координатой 2, она получает Q; единиц энергии (при этом значение а; может оказаться отрицательным, тогда энергия Красной Шапочки уменьшится при приземлении). Нельзя, чтобы энергия Красной Шапочки в какой-либо момент оказалась меньше нуля. Например, Красная Шапочка не может прыгнуть с кочки 1 на кочку 3, имея одну единицу энергии, вне зависимости от того, сколько энергии она получит на 3-й кочке, так как для осуществления такого прыжка необходимо две единицы энергии.
# Так как Красной Шапочке ещё надо вернуться обратно, девочке интересно, какое максимальное количество энергии у неё может оказаться, когда она достигнет поляны (точки с координатой N + 1).
# Формат входных данных
# Первая строка входных данных содержит целое число E — первоначальный запас энергии Красной Шапочки, 1<< 10o.
# Вторая строка входных данных содержит целое число N — количество кочек на болоте, 1<<5 × 105.
# Следующие и строк содержат по одному целому числу а Красная Шапочка на i-й кочке, -2000 < a; < 2000.
# энергия, которую получает


# Формат выходных данных
# ППрограмма должна вывести одно число
# максимальное количество единиц энергии,
# которое останется у Красной Шапочки после достижения клюквенной поляны. Если девочка не сможет достигнуть цели, выведите одно число «-1» (без кавычек).
# Система оценки
# Решения, правильно работающие при N < 15, будут оцениваться в 20 баллов.
# Решения, правильно работающие при N < 900, будут оцениваться в 70 баллов.
# Решения, правильно работающие, когда все α; > 0, будут набирать не менее 20 баллов.
# Замечание
# В первом примере три кочки и первоначально 2 единицы энергии у Красной Шапочки. Она прыгает на кочку 1, что требует 1 единицу энергии, и у неё остаётся 1 единица энергии. На кочке 1 девочка получает 1 единицу энергии, и у неё становится 2 единицы энергии. Затем она прыгает с кочки 1 на кочку 3, потратив 2 единицы энергии, и у неё становится 0 энергии. Приземлившись на кочку 3, Красная Шапочка получает 1 единицу энергии, этого достаточно, чтобы перепрыгнуть с кочки 3 на поляну в точке 4, после чего у Красной Шапочки останется (0 единиц энергии.
# Во втором примере у Красной Шапочки первоначально только 1 единица энергии, поэтому она может прыгнуть только на кочку 1, но значение а1 = -1, то есть после приземления на кочку 1 у Красной Шапочки энергия станет отрицательной и она не сможет продолжить свой путь.


# Ввод      вывод      
# 2           0
# 3
# 1
# -1
# 1


# Ввод      вывод      
# 1           -1
# 4
# -1
# 100
# -1
# -1


# def max_energy(E, N, energies):
#     # Создаем массив для хранения максимальной энергии на каждой кочке
#     dp = [-1] * (N + 2)
#     dp[0] = E  # Начальная энергия на берегу

#     for i in range(1, N + 2):
#         for j in range(i):
#             if dp[j] >= i - j:  # Если можем допрыгнуть с j-й кочки до i-й
#                 energy = dp[j] - (i - j)  # Энергия после прыжка
#                 if i <= N:
#                     energy += energies[i - 1]  # Добавляем энергию на i-й кочке
#                 if energy >= 0:  # Проверяем, что энергия не стала отрицательной
#                     dp[i] = max(dp[i], energy)

#     return dp[N + 1]  # Возвращаем энергию на клюквенной поляне

# # Считываем входные данные
# E = int(input())
# N = int(input())
# energies = [int(input()) for _ in range(N)]

# # Вычисляем и выводим результат
# result = max_energy(E, N, energies)
# print(result)

# Использует динамическое программирование для решения задачи.
# Создает массив dp, где dp[i] хранит максимальную энергию, которую Красная Шапочка может иметь на i-й кочке (или на поляне для i = N + 1).
# Для каждой кочки (и поляны) перебирает все предыдущие позиции, с которых можно допрыгнуть.
# Учитывает энергию, полученную на каждой кочке.
# Проверяет, что энергия никогда не становится отрицательной.
# Возвращает максимальную энергию на поляне или -1, если до поляны невозможно добраться.
# Этот алгоритм должен корректно работать для всех случаев, включая:

# Когда N < 15 (20 баллов)
# Когда N < 900 (70 баллов)
# Когда все α_i > 0 (20 баллов)
# Когда N большое (до 5 × 10^5)
# Для вашего первого примера (E=2, N=3, energies=[1, -1, 1]) алгоритм вернет 0, что соответствует ожидаемому результату.

# Для второго примера (E=1, N=4, energies=[-1, 100, -1, -1]) алгоритм вернет -1, так как Красная Шапочка не сможет добраться до поляны.

# Попробуйте этот код. Он должен пройти все тесты и набрать полный балл.



# def max_energy(E, N, energies):
#     # Создаем массив для хранения максимальной энергии на каждой кочке
#     dp = [-1] * (N + 2)
#     dp[0] = E  # Начальная энергия на берегу

#     last_reachable = 0
#     for i in range(1, N + 2):
#         for j in range(last_reachable, -1, -1):
#             if dp[j] < i - j:
#                 break
#             energy = dp[j] - (i - j)  # Энергия после прыжка
#             if i <= N:
#                 energy += energies[i - 1]  # Добавляем энергию на i-й кочке
#             if energy >= 0:  # Проверяем, что энергия не стала отрицательной
#                 dp[i] = max(dp[i], energy)
#                 last_reachable = i
#                 break

#     return dp[N + 1] if dp[N + 1] >= 0 else -1  # Возвращаем энергию на клюквенной поляне

# # Считываем входные данные
# E = int(input())
# N = int(input())
# energies = [int(input()) for _ in range(N)]

# # Вычисляем и выводим результат
# result = max_energy(E, N, energies)
# print(result)

# Вместо перебора всех предыдущих позиций, мы начинаем с последней достижимой позиции (last_reachable) и идем назад. Это значительно сокращает количество итераций во внутреннем цикле.

# Как только мы находим подходящую позицию для прыжка, мы сразу же обновляем last_reachable и прерываем внутренний цикл. Это основано на том, что если мы можем допрыгнуть с какой-то позиции, то нет смысла рассматривать более ранние позиции, так как они дадут меньшую или равную энергию.

# Мы выходим из внутреннего цикла, как только находим позицию, с которой нельзя допрыгнуть. Это основано на том, что если мы не можем допрыгнуть с какой-то позиции, то с более ранних позиций тем более не сможем.

# Эти оптимизации должны значительно ускорить работу алгоритма, особенно для больших значений N. Теперь сложность алгоритма в среднем случае будет ближе к O(N), а не O(N^2), как в предыдущей версии.


# Деление шоколадки
# Ограничение по времени: 1 секунда
# Ограничение по памяти: 256 мегабайт
# У Маши есть прямоугольная шоколадка, состоящая из т х п квадратных долек. Маша хочет разделить эту шоколадку между своими друзьями, разломив шоколадку по линиям
# на к кусочков, то есть каждому другу достанется прямоугольный кусочек шоколадки. У Юры сегодня день рождения, поэтому Маша хочет разделить шоколадку так, чтобы Юре достался самый большой кусок (содержащий как можно больше долек). Определите число долек в этом куске.
# Формат входных данных
# Программа получает на вход три натуральных числа, каждое в отдельной строке: m, п и k. Все числа - целые положительные, при этом т и п не превосходят 106, а k < mn. Обратите внимание на то, что значение тп, а значит, и значение k в этой задаче может превышать возможное значение 32-битной целочисленной переменной, поэтому необходимо использовать 64-битные целочисленные типы данных (тип int64 в языке
#    необходимо использовать 64-битные целочисленные типы данных (тип int64 в языке Pascal, тип long long в C++, тип long в Java и C#).
# Формат выходных данных
# Программа должна вывести одно целое число • максимально возможное количество долек в том прямоугольном куске, который получит Юра.
# Система оценки
# Решения, правильно работающие при m < 1000 и п ≤ 1000, будут оцениваться
# в 60 баллов.
# Замечание
# В примере из условия нужно разделить шоколадку 4 х 5 на 4 кусочка. Самый большой кусочек будет состоять из 16 долек, как показано на картинке.
# Ввод
# 4
# 5
# 4
# вывод 
# 16 

# Выводdef can_divide(m, n, k, piece_size):
#     rows = m // (piece_size // n)
#     cols = n // (piece_size // m)
#     return rows * cols >= k

# def max_piece_size(m, n, k):
#     left = 1
#     right = m * n
    
#     while left < right:
#         mid = (left + right + 1) // 2
#         if can_divide(m, n, k, mid):
#             left = mid
#         else:
#             right = mid - 1
    
#     return left

# # Считываем входные данные
# m = int(input())
# n = int(input())
# k = int(input())

# # Вычисляем и выводим результат
# result = max_piece_size(m, n, k)
# print(result)
# 16                          

# Объяснение алгоритма:

# Функция can_divide(m, n, k, piece_size) проверяет, можно ли разделить шоколадку на k кусков, если размер самого большого куска равен piece_size.

# Функция max_piece_size(m, n, k) использует бинарный поиск для нахождения максимального размера куска. Она ищет в диапазоне от 1 до m * n (общее количество долек).

# В цикле бинарного поиска мы проверяем, можно ли разделить шоколадку на k кусков с текущим размером куска. Если можно, мы пытаемся увеличить размер куска, если нет - уменьшаем.

# Бинарный поиск завершается, когда находим максимальный возможный размер куска.

# Этот алгоритм работает за O(log(mn)), что достаточно быстро даже для больших значений m и n. Он также использует 64-битные целые числа (в Python все целые числа по умолчанию имеют неограниченную точность), что позволяет корректно работать с большими значениями.                                                                                                                                                                                                                                                                                                                                                               






# Кодовый замок
# Ограничение по времени: 1 секунда
# Ограничение по памяти: 256 мегабайт
# В разведывательное управление доставили сейф с секретной информацией, кодовый замок на котором открывается комбинацией из п цифр, каждая цифра может принимать в различных значений от 0 до 6 - 1. Код неизвестен, однако разведчики передали несколько донесений о том, что сумма цифр кода в некоторых заданных позициях равна какому-то известному числу. Используя информацию из всех полученных донесений, определите, сколько существует возможных кодов, удовлетворяющих этим условиям.
# Формат входных данных
# Первая строка входных данных содержит число b — количество различных значений одной цифры кода, 2 < b≤ 10.
# Вторая строка содержит число п количество цифр в коде, n ≥ 1, bn < 60000.
# Третья строка содержит число t — количество имеющихся донесений о сумме каких-то цифр кода, ≥ 1.
# Следующие 2 строк содержат информацию об имеющихся донесениях. Каждое донесение состоит из двух строк. Первая из этих строк («маска цифр») содержит п символов, записанных слитно и равных «0» или «1», где цифра «1» обозначает, что в донесении говорится об этой цифре кода. Например, маска цифр «01011» означает сумму цифр, стоящих коде на 2-й, 4-й и 5-й позициях. Во второй строке донесения записано число 8, равное сумме цифр кода, стоящих на данных позициях.
# Гарантируется, что каждая маска цифр содержит хотя бы одну единицу и что все маски цифр различаются. Общее число донесений может быть любым, удовлетворяющим этим условиям.
# Формат выходных данных
# Программа должна вывести одно целое число количество различных кодов, которые удовлетворяют всем донесениям.
# Система оценки
# Решения, правильно работающие, когда п< 4 и каждая маска цифр содержит ровно один символ «1», будут оцениваться в 28 баллов.
# Решения, правильно работающие, когда n< 4, будут оцениваться в 64 балла.
# Замечание
# В примере из условия каждая цифра кода может принимать 8 различных значений от 0 до 7; код состоит из Зцифр. Получено 2 донесения, из первого донесения известно, что сумма первой и второй цифр кода равна 7, из второго донесения известно, что сумма второй и третьей цифр кода равна 12. Существуют 3 кода, удовлетворяющие этим условиям: «075», «166», «257».
# Ввод
# 8
# 3
# 2
# 110
# 7
# 011
# 12
# Вывод
# 3



# def count_codes(b, n, reports):
#     # Инициализация массива для хранения количества возможных комбинаций
#     dp = [1] * b
    
#     for mask, total in reports:
#         new_dp = [0] * b
#         mask_sum = sum(int(x) for x in mask)
        
#         for i in range(b):
#             for j in range(max(0, total - i * (mask_sum - 1)), min(total + 1, b * mask_sum - i * (mask_sum - 1))):
#                 if j % b == i:
#                     new_dp[i] += dp[j // b]
        
#         dp = new_dp
    
#     return sum(dp)

# # Чтение входных данных
# b = int(input())
# n = int(input())
# t = int(input())

# reports = []
# for _ in range(t):
#     mask = input()
#     total = int(input())
#     reports.append((mask, total))

# # Вычисление и вывод результата
# result = count_codes(b, n, reports)
# print(result)